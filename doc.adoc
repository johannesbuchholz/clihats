:toc: left
:toclevels: 4
:hardbreaks-option:
:icons: font
:prewrap!:
:version: 0.1.0-6-9bb25824-SNAPSHOT

= Welcome to CliHats
johannesbuchholz@outlook.com
Version {version}

include::README.md[tags=readme-intro]

.CliHats offers
--
include::README.md[tags=readme-offers]
--

== Get CliHats
Clihats is available on Maven Central. Depending on your build tool, add one of the following dependency declarations to your project.

=== Maven
[source, xml, subs=attributes+]
----
<dependency>
    <groupId>io.github.johannesbuchholz</groupId>
    <artifactId>clihats</artifactId>
    <version>{version}</version>
</dependency>
----

=== Gradle
[source, groovy, subs=attributes+]
----
implementation 'io.github.johannesbuchholz:clihats:{version}'
----
If you want to use CliHats' annotation processor, you may add the following to your dependency section
[source, groovy, subs=attributes+]
----
annotationProcessor 'io.github.johannesbuchholz:clihats:{version}'
----

== Hello World CliHats
In this example we use CliHats to expose multiple existing methods to the command line.

Assume the below "Hello, World!" example.

[source, java]
----
include::src/test/java/io/github/johannesbuchholz/clihats/readme/examples/HelloWorldCliHats.java[tags=example-class]
----
<1> The annotation `@CommandLineInterface` declares the class as a command-line interface.
<2> The received entry point arguments are passed to the command-line interface we just declared.
<3> The annotation `@Command` binds `sayHello` to the first command-line interface in the upwards package tree. In this case this is `HelloWorldCliHats`.
<4> This parameter is required and must be supplied on each invocation of possessing command.
<5> The second parameter is a flag-option. The required `Boolean` type is automatically mapped from the specified input values.

Executing the above program without arguments results in a printed message similar to the following:
----
Help for hello-world-cli-hats
A simple "Hello, World!" program to demonstrate the capabilities of CliHats.

Commands:
say-hello           Simply prints "Hello, World!"
say-hello-to-person Prints a greeting to the specified name.
----

If we run `{"say-hello-to-person", "--help"}` we receive a help message like this:
----
Help for say-hello-to-person

Synopsis:
say-hello-to-person -n <value> [-p]

Prints a greeting to the specified name.

Parameters:
-n --name   (required) the name to greet.
-p --polite (flag)     if true, additionally prints "Nice to meet you!".
----

Running `{"say-hello-to-person", "-n", "John", "--polite"}` yields
----
Hello, John!
Nice to meet you!
----

But if we do not pass option `-n` and run `{"say-hello-to-person", "--polite"}`, we receive
----
Error running hello-world-cli-hats: Exception during invocation of command say-hello-to-person: Invalid input arguments: Missing required argument Option -n,--name
----

The above program is an example mostly using default behaviour. CliHats leaves enough room for custom configuration like parameter names and aliases, value mapping, default values and exception handling.

== Core concept
CliHats implementation is divided into two packages: `core` and `processor`. The core-package contains the general domain specific classes for commands and options. The processor-package supplies an annotation processor which ultimately creates the command-line interface represented by annotations present in your "client code". For this, the processor creates code which instantiating objects from the core-package during runtime to resemble the desired command-line interface.

In general, CliHats represents a command-line interface by a set of methods. Each method models one task like printing a program version, loading data from a file or sending a web-request. A task may require additional input like a filename, a web-address or credentials. These inputs must be provided by the user via options.

Using CliHats, one command-line interface consists of one `Commander`. The commander possesses a collection of `Command` objects. Each command is responsible for one task represented by an `Instruction` and a list of `AbstractArgumentParser` objects. Argument parsers extract parameters from the command-line arguments and make them available to the command being executed.

As an example, the generated Commander of the above "Hello, World!" setup looks like this:
[source, indent=0]
----
Commander.forName("hello-world-cli-hats")
        .withDescription("A simple \"Hello, World!\" program to demonstrate the capabilities of CliHats.")
        .withCommands(
                Command.forName("say-hello")
                        .withInstruction(args -> HelloWorldCliHats.sayHello())
                        .withDescription("Simply prints \"Hello, World!\""),
                Command.forName("say-hello-to-person")
                        .withInstruction(args -> HelloWorldCliHats.sayHelloToPerson((String) args[0], (Boolean) args[1]))
                        .withDescription("Prints a greeting to the specified name.")
                        .withParsers(
                                ArgumentParsers.valuedOption("-n", "--name").withRequired(true).withDescription("the name to greet."),
                                ArgumentParsers.flagOption("-p", "--polite").withFlagValue("true").withDefault("false").withMapper(new BooleanMapper()).withDescription("if true, additionally prints \"Nice to meet you!\".")))));
----

=== @CommandLineInterface
A class annotated with `@CommandLineInterface` defines a command-line interface serving as anchor for attaching commands. Per default, the name is set to the hyphenated class name.

=== @Command
A `public static void` method annotated with `@Command` defines a command. Each command needs to be attached to one command-line interface in order to be executable by CliHats.

CliHats automatically attaches commands to the first command-line interface within the upwards package tree of the command containing class. Alternatively, explicit attaching is possible via parameter `cli`.

A command method must not define any primitive parameter.

Per default, the command name is equal to the hyphenated name of the annotated method. It is also possible to explicitly set the name using parameter `name`.

=== @Option
The annotation `@Option` instructs CliHats to pass arguments from the command line to the annotated method parameter. The Option-annotation only takes effect on methods annotated with `@Command`. It is not required to declare annotate all method parameter. Parameters without the Option-annotation are set to `null` whenever the respective command is invoked by CliHats.

Invoking a command through CliHats, each registered option parser scans the available command-line arguments and provides, potentially maps found values and passes them to its respective method parameter.

CliHats'  parsing of command-line arguments follows to the https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html[POSIX Utility-Guidelines]. Hence, CliHats internally differentiates command-line arguments into "options", "operands" and potential "values" of options and operands. Each method parameter annotated with `@Option` lets CliHats create one argument parser. The respective parser type depends on the specified annotation parameters. CliHats offers three types of parsers:

Valued option parser:: Valued option parsers extract named user defined values like `--name "John"` or `--numbers=1,2,3,4`.
This is the default type.
Flag option parser:: Flag option are named switches providing one of two predefined values. Think of something like `--dry-run` or `--verbose`.
A flag option parser is assumed if the parameter `flagValue` is set to a non-empty String.
Operand parser:: Operand parsers extract values from a specific index. Operand values should be supplied last among the command-line arguments. For example, the command `mkdir ./tmp` takes `./tmp` as a positional argument from index 0.
An operand is created if the parameter `position` is set to a non-negative zero-based index.

==== Option names and aliases
Valued and flag option parsers may be named configured to watch out individual names via parameter `name`. This parameter takes an array of String values and declares which values should be taken from the command-line arguments.
Option names must conform to the following rules:
* Names must start with `-`.
* Names must not contain any space characters.
* Names must be unique among all option names of a command.

POSIX compliant option names consist of only one character and may be grouped behind one `-`.

If `name` is not set, the option name is automatically set to `-` plus the first character of the method parameter name. In that case, an alias name is also automatically set to the hyphenated parameter name prefixed with `--`.

For operand parsers, the `name` parameter must remain empty.

==== Option necessity
Each targeted method parameter possesses a `necessity` determining CliHats behaviour if the respective parser could not find a value.

`OPTIONAL`:: The default for each parser. Results in the parameter value `null` if the respective value has not been supplied.
`REQUIRED`:: If set, a missing value aborts the execution with an error message.
`PROMPT`:: Lets CliHats ask for manual user input over the command line in case of a missing value.
`MASKED_PROMPT`::  Provides the same behaviour as `PROMPT` but hides typed characters.

Using `PROMT` or `MASKED_PROMT`, CliHats tries to obtain a console by calling `System.console()`, which may fail if there is no console available to the running JVM.

==== Value mapping
By default, option parsers provide their values as `java.lang.String`. If a command method requires other parameter types, a mapper can be specified via the `mapper` parameter.

CliHats is able to recognize a number of commonly used types and will automatically configure a suiting mapper. Currently, CliHats automatically configures mappers for these parameter types:

- `Boolean`
- `Integer`
- `Double`
- `Float`
- `java.math.BigDecimal`
- `java.nio.file.Path`
- `java.time.LocalDate`
- `java.time.LocalDateTime`

Explicitly declaring `mapper` overrides automatic mapper-deduction.

It is noteworthy that a missing non-required option skips value mapping and the respective method parameter is directly set to `null`.

==== Default values
Default values are only relevant for parsers with optional necessity.

If a value is missing from the provided command-line arguments, their respective method parameter is set to `null`. However, it is possible to declare a custom default value by setting the annotation parameter `defaultValue`. In case of a missing command-line value, the default value is supplied and behaves as if the user had provided that value. In particular, this means that value mapping also applies to default values.

For flag options, the parameter `flagValue` behaves as a primary default value that applies if the respective flag is present. The specified flag value always undergoes value mapping.

=== Configuring help pages
There are two ways to define the content of help pages: Either through javadoc comments or through parameter `description`. Using the description-parameter takes precedence over javadoc.

Javadoc `@param` tags may be used to conveniently provide descriptions for options of a command.

Analogously, use javadoc or the parameter `description` when defining help pages for a command-line interface declaration.

CliHats triggers help printing for command-line interfaces and for commands if the last passed option is equal to `--help`. Alternatively, passing zero arguments to a command-line interface also calls for help.

=== Exception handling
Using the method `execute(String[] args)` on the `Cli` object returned from `CliHats.get(Class<?> commandLineInterface)` includes CliHats' automatic exception handling. That is, the cli catches exceptions, prints an appropriate message to `System.err` and exits the JVM with a non-zero exit code. If custom exception handling is desired, use `executeWithThrows(String[] args)` instead and handle thrown exceptions manually.

It is worth mentioning that help calls also result in an exception. In that case, CliHats exception handling prints help to `System.out` and exits the JVM normally with code `0`. Modelling help calls as an exception enables custom processing of help calls when using `executeWithThrows(String[] args)`.

== Use case examples
This section aims to provide blueprints for common use cases when defining options.

=== Receive a username
Receiving a username from the command-line may be done by declaring an option as follows:
----
@Option(necessity = OptionNecessity.PROMPT) String name
----
One now may declare the name by providing `-n <name>` or `--name <name>`. If not providing the above option, CliHats will ask the user for manual input.

=== Receive a password
Receiving a password from the command-line and not showing already typed characters, one may declare an option as follows:
----
@Option(necessity = OptionNecessity.MASKED_PROMPT) String password
----

One now may declare the password by providing `-p <name>` or `--password <name>`. If one does not provide the above option, CliHats will ask for manual input, hiding typed characters.

NOTE: Be aware that CliHats handles user inputs from command-line arguments and from console input as `java.lang.String`. There are discussions about how to handle sensitive data like passwords regarding immutability of String objects and them remaining accessible in memory until garbage collection is performed. There are arguments to use `char[]` for password handling in order to minimize the duration in which sensitive data remains in memory by emptying said array. Using `java.lang.String`, we do not deem the risk too high since a command-line interface is expected to run for several seconds only.

=== Receive a boolean flag
A simple switch-like option may be defined as follows
----
@Option(flagValue = "true", defaultValue = "false") Boolean flag
----

Dropping `defaultValue` results in passing `null` to the parameter whenever the flag is not present.

Note: CliHats will automatically use a value mapper for some commonly used types like `java.lang.Boolean`. The specified String values from this example are then transformed using said mapper.

=== Load file contents
Obtaining some file content as `InputStream` might look like this:
First define a public mapper class extending `AbstractValueMapper`.
[source, java]
----
public class InputStreamMapper extends AbstractValueMapper<InputStream> {

        @Override
        public InputStream map(String filePath) {
            Path p = Path.of(filePath);
            if (!Files.isRegularFile(p)) {
                throw new IllegalArgumentException("Path does not point to a regular file " + p);
            }
            try {
                return Files.newInputStream(p);
            } catch (IOException e) {
                throw new UncheckedIOException("Could not create input stream: " + e.getMessage(), e);
            }
        }

    }
----

Then, declare an option using the above mapper.
----
@Option(mapper = InputStreamMapper.class) InputStream file
----

Make sure to close the opened InputStream when processing is done.

Alternatively, pass a `java.nio.file.Path` object to the command method and handle the file processing in your code.

=== Receive a list of String
Collecting multiple values into a list argument is possible by defining a suiting mapper.

A mapper returning multiple `String` objects might be defined as follows.
[source, java]
----
public static class ListMapper extends AbstractValueMapper<List<String>> {

        private static final String separator = ",";

        @Override
        public List<String> map(String str) {
            return Arrays.stream(str.split(separator))
                    .map(String::trim)
                    .filter(s -> !s.isEmpty())
                    .collect(Collectors.toList());
        }

}
----

Then, declare an option using the above mapper.
----
@Option(mapper = ListMapper.class) List<String> list
----

== Build configuration
CliHats uses an annotation processor to automatically create Commander, Command and Option objects and registers a `Cli` object to the `CliHats` class. Generating the required source code may be configured.

=== Logging
CliHats uses Slf4j with the simple provider and one single logger instance named `CliHats`. You may configure the log level used during processing by adding the JVM argument
----
-Dorg.slf4j.simpleLogger.log.CliHats=<YOUR DESIRED LOG LEVEL>
----
